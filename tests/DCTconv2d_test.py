# -*- coding: utf-8 -*-
"""confirming DCT implementation.ipynb

Automatically generated by Colaboratory.

"""
# run from a folder which has access to importing 'modules'

import numpy as np
import scipy as sp
from scipy.fft import dct
import torch
from modules import DCTconv2d

"""**Testing our DCTconv2d layer**: We want to confirm that our layer is doing the DCT of each patch.
To test this we implement our own convolution by hand, using Scipy's DCT, and compare this with the
output of a DCTconv2d on the same input. We see expected that they are equal. We repeate this for both
cases of needing to pad the input of the DCT and truncate the output of the DCT."""

# create  input
in_channels = 10
x = np.random.normal(size = (1,32,32,in_channels))

# By hand calculate DCT of each patch

num_filters = 20
k = 3
output = np.zeros((1, 32-k+1, 32-k+1, num_filters))
for i in range(32-k+1):
  for j in range(32-k+1):
    x_patch = x[:,i:i+k,j:j+k,:]
    x_patch_vec = np.reshape(x_patch, -1)
    if len(x_patch_vec)<num_filters:
      padded_x_patch = np.zeros(num_filters)
      padded_x_patch[:len(x_patch_vec)] = x_patch_vec
      output[:, i,j,:] = sp.fftpack.dct(padded_x_patch, norm='ortho')
    else:
      output[:, i,j,:] = sp.fftpack.dct(x_patch_vec, norm='ortho')[:num_filters]

# Create DCTconv2dlayer and reshape input for Pytorch
layer = DCTconv2d(10, 20, 3, 1, padding=0)
x_torch = np.transpose(x, (0,3,1,2))

# Pass input through the layer
layer_output = layer(torch.Tensor(x_torch))

# Check that they are equal (minus numerical errors)
output = np.transpose(output, (0,3,1,2))
if np.sum(np.isclose(layer_output.numpy(), output, atol=1e-06)) == np.product(output.shape):
    print("DCTconv2d gives correct output")

# create  input
in_channels = 3
x = np.random.normal(size = (1,32,32,in_channels))

# By hand calculate DCT of each patch

num_filters = 30
k = 3
output = np.zeros((1, 32-k+1, 32-k+1, num_filters))
for i in range(32-k+1):
  for j in range(32-k+1):
    x_patch = x[:,i:i+k,j:j+k,:]
    x_patch_vec = np.reshape(x_patch, -1)
    if len(x_patch_vec)<num_filters:
      padded_x_patch = np.zeros(num_filters)
      padded_x_patch[:len(x_patch_vec)] = x_patch_vec
      output[:, i,j,:] = sp.fftpack.dct(padded_x_patch, norm='ortho')
    else:
      output[:, i,j,:] = sp.fftpack.dct(x_patch_vec, norm='ortho')[:num_filters]

# Create DCTconv2dlayer and reshape input for Pytorch
layer = DCTconv2d(in_channels, num_filters, 3, 1, padding=0)
x_torch = np.transpose(x, (0,3,1,2))

# Pass input through the layer
layer_output = layer(torch.Tensor(x_torch))

# Check that they are equal (minus numerical errors)
output = np.transpose(output, (0,3,1,2))
if np.sum(np.isclose(layer_output.numpy(), output, atol=1e-6)) == np.product(output.shape):
    print("DCTconv2d gives correct output")
